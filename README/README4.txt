chromedriver

현재 크롤링은 정해진 url만 처리
이런 상태를 static이라 한다.

dynamic은 payload로 url을 주면
재활용해서 서로 다른 결과를 만드는 것이다.
=============================================

MVC 코딩하는 순서...

구조 (frame)을 만든다.
1. model -> view -> controller 연결(network)한다...
model = ebtity + service 속성 + 기능 => 모델객체
view = Reactjs로 전환된다...

model과 view가 언어가 다르다.

서로의 언어를 모르는 한국인, 미국인처럼
data를 주고받으려면 통역이 필요..
그 통역을 controller가 맡는다. 통역의 국적은 한국인

pyhton과 javascript의 만남. 서로 syntax가 다르다.
그래서 transfer를 부른다. data를 주고 받을 수 있다..
flask가 transfer역할을 하고 그 통역을 python이 한다.

각각 하는 일이 다르다.
뇌의 역할을 하는 python이다.

플젝을 만드는데 칩을 이식하면 단기간에 성능이 올라간다.
유료칩(스타트업)도 있고, 무료칩도 있는데 이 중 성능이 검증된
유명한 것이 텐서플로우(구글), 파이토치(페이스북)이 양강이라고 한다.

이 과정은 텐서플로 사용법을 배우는 과정으로 편성되어서,

코딩 컨벤션을 결국 텐서플로에 최적화 시켜야 한다..
그래서 객체지향(class 단위) 방식으로 바꾼 것이다.

인공지능을 담당하는 미세조정 파트는 텐서플에 의존한다..

이제 구조를 잡았으니, 디테일한 파트인 알고리즘으로 넘어간다.

machine vs model difference

컴공에서는 상태를 통해 구분 state
머신은 러닝, 모델은 러닝을 하지 않는다..

모델을 만듦에도 모델 러닝이 아니라 머신 러닝을 시킨다.

그리고 알고리즘을 공부하는 목적이 이곳에서(머신러닝에서는)
본인이 이 알고리즘을 공부하는 것이 아니라 내가 만든 머신을 공부시키는
것이다란 개념을 잡고 있어야 한다.

이 머신을 신생아로 비유할 수 있다. 그리고 개발자의 평가는 이 baby가
똑똑해져서 이 baby가 내는 performance가 나의 성과가 된다..

허사비스가 이세돌과 바둑둔게 아니라 알파고가 둔 것이다.

우리의 고민은 어떤 알고리즘을 우리가 만드는 모델에 주입을 시킬 것인가 하는 지점이다..

이제 모델을 만들려 한다.
첫번째는 모델을 훈련시킬 데이터에서 쓰레기값을 제거하는 것이다.
이 머신은 타이타닉의 정보를 통해 만약 A라는 가상의 인물이 당시 1912년 침몰 당시
타이타닉에 승선했다면 생존확률을 어찌 될 것인가?
더 나아가 현재 승객 안전을 위한 조치를 어떻게 하면 비슷한 사고 발생시
생존률을 올릴 수 있을 것인가 하는 문제로 귀결될 수 있다.

우리는 단순하게 생존확률 판단 머신만 만든다..

1순위 작업은 feature를 줄이는 것이다.